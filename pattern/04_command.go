package pattern

import "fmt"

/*
	Реализовать паттерн «комманда».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Command_pattern
*/

/*
	Паттерн Команда преобразует все параметры операции или события в объект-команду.
	Впоследствии можно выполнить эту операцию, вызвав соответствующий метод объекта.
	Объект-команда заключает в себе всё необходимое для проведения операции, поэтому её легко выполнять, логировать и отменять.
	На основе этого паттерна устроена, например, система Undo в десктопных приложениях.

	Паттерн Команда применяется, когда:
		нужно преобразовать операции в объекты, которые можно обрабатывать и хранить: использование объектов вместо операций позволяет создавать очереди, передавать команды дальше или выполнять их в нужный момент;
		требуется реализовать операцию отмены выполненных действий.

	Команда применяется в работе с базами данных.
	В стандартной библиотеке Go есть пример SQL-инструкции sql.Stmt.
	Такую заранее подготовленную инструкцию можно многократно выполнять методом Stmt.Exec, не задумываясь о её внутренней структуре.
	sql.Stmt, выполненную в рамках транзакции Tx.Stmt(), легко откатить с помощью Tx.Rollback().

	Ещё одна область применения Команды — сетевое, распределённое программирование, архитектура микросервисов.
	Шаблон используется, когда сервис должен предоставить клиенту набор операций в простом и удобном интерфейсе, не требующем понимания внутренней архитектуры сервиса.
	Например, пакет net/rpc стандартной библиотеки позволяет серверу зарегистрировать объект как сервис и сделать его методы доступными для вызова удалённым клиентом.

	В классической формулировке паттерн Команда работает с четырьмя сущностями:
		command — объект, который знает все методы receiver и вызывает один из них, а также хранит параметры для вызова. Команда выполняется вызовом своего метода execute().
		receiver — непосредственный исполнитель команды. Методы этого объекта и совершают фактическую работу.
		invoker — объект, который знает интерфейс команд, умеет их вызывать, пользуясь только этим интерфейсом. Не зависит от внутреннего устройства команд.
		client — код клиента, который оркестрирует сервисы command, receiver, invoker. Это высокоуровневый код, пользуется только интерфейсами сервисов, не зависит от их внутренней реализации.

	Команда применяется, когда:
		нужно преобразовать запросы в объекты, что позволяет передавать, обрабатывать и хранить их;
		нужно создать очередь операций и работать с ней;
		нужно откатить выполненные действия.

	Недостатки:
		Код становится сложнее в написании, потому что надо прописать много новых структур, интерфейс,
		это не всегда оправдано в ситуациях, когда система компактная и не содержит большого обилия команд
*/

// интерфейсы
type command interface {
    execute()
}

type receiver interface {
    action()
}

// реализация invoker
type invoker struct {
    commands map[string]command
}

func newInvoker() *invoker {
    i := new(invoker)
    i.commands = make(map[string]command)
    return i
}

func (i *invoker) do(c string) {
    i.commands[c].execute()
}

// реализация command
type printer struct {
    receiver receiver
}

func (c *printer) execute() {
    c.receiver.action()
}

// реализация receiver
type rcvr struct {
    name string
}

func (r *rcvr) action() {
    fmt.Println(r.name)
}

// func main() {
//     // клиентский код
//     var rcvr1 = rcvr{"John Doe"}
//     var cmd1 = printer{&rcvr1}
//     var rcvr2 = rcvr{"Hello, world!"}
//     var cmd2 = printer{&rcvr2}
//     invkr := newInvoker()
//     invkr.commands["print_name"] = &cmd1
//     invkr.commands["print_hello"] = &cmd2
//     // собственно применение команд
//     invkr.do("print_name")
//     invkr.do("print_hello")
// } 
